<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>HybridConnect Chat</title>

  <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>

  <style>
    :root{
      --bg:#f6f7fb;
      --card:#ffffff;
      --border:#e6e8ef;
      --text:#1f2937;
      --muted:#6b7280;
      --primary:#2563eb;
      --badge:#ef4444;
      --shadow:0 6px 18px rgba(15,23,42,.06);
      --radius:14px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0; font-family: Arial, sans-serif;
      height:100vh; display:flex; background:var(--bg); color:var(--text);
    }

    /* Left */
    #left{
      width:320px; min-width:280px; max-width:35vw;
      border-right:1px solid var(--border);
      background:var(--card);
      display:flex; flex-direction:column;
    }
    #leftHeader{
      padding:14px 14px 10px 14px;
      border-bottom:1px solid var(--border);
    }
    #meLine{ font-size:12px; color:var(--muted); }
    #search{
      width:100%; margin-top:10px; padding:10px 12px;
      border:1px solid var(--border); border-radius:10px; outline:none;
    }
    #conversations{
      overflow-y:auto; padding:8px;
    }

    .conv{
      display:flex; gap:10px;
      padding:10px; border:1px solid transparent;
      border-radius:12px; cursor:pointer;
      transition:.15s;
    }
    .conv:hover{ background:#f3f4f6; }
    .conv.active{
      background:#eef2ff;
      border-color:#c7d2fe;
    }

    .avatar{
      width:42px; height:42px; border-radius:50%;
      background:#e5e7eb; flex:0 0 42px;
      overflow:hidden; display:flex; align-items:center; justify-content:center;
      font-weight:bold; color:#374151;
    }
    .avatar img{ width:100%; height:100%; object-fit:cover; }

    .convMain{ flex:1; min-width:0; }
    .convTop{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .name{ font-weight:700; font-size:14px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .time{ font-size:12px; color:var(--muted); white-space:nowrap; }
    .preview{
      margin-top:4px; font-size:13px; color:var(--muted);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }

    /* ‚úÖ typing preview style */
    .preview.typing{
      color: var(--primary);
      font-style: italic;
      font-weight: 700;
    }

    .badge{
      background:var(--badge); color:#fff; font-size:12px;
      padding:2px 8px; border-radius:999px; margin-left:8px;
      font-weight:700;
    }

    /* Right */
    #right{
      flex:1; display:flex; flex-direction:column;
      min-width:0;
    }
    #chatHeader{
      background:var(--card);
      border-bottom:1px solid var(--border);
      padding:14px 16px;
      display:flex; align-items:center; justify-content:space-between;
    }
    #chatTitle{ font-weight:800; }
    #status{ font-size:12px; color:var(--muted); min-height:16px; }

    #messagesWrap{
      flex:1; overflow-y:auto;
      padding:16px;
    }

    .bubbleRow{ display:flex; margin:8px 0; }
    .bubbleRow.me{ justify-content:flex-end; }
    .bubbleRow.other{ justify-content:flex-start; }

    .bubble{
      max-width:min(640px, 78%);
      padding:10px 12px;
      border-radius:16px;
      box-shadow: var(--shadow);
      border:1px solid var(--border);
      background:var(--card);
      line-height:1.3;
      white-space:pre-wrap;
      word-wrap:break-word;
    }
    .bubble.me{
      background:#e8efff;
      border-color:#c7d2fe;
    }
    .meta{
      margin-top:6px; font-size:11px; color:var(--muted);
      display:flex; gap:10px; align-items:center;
    }
    .seenDot{ font-size:11px; color:var(--muted); }

    #composer{
      background:var(--card);
      border-top:1px solid var(--border);
      padding:12px;
      display:flex; gap:10px; align-items:center;
    }
    #text{
      flex:1;
      padding:12px 12px;
      border:1px solid var(--border);
      border-radius:12px;
      outline:none;
      font-size:14px;
    }
    #sendBtn{
      padding:12px 14px;
      border:none; border-radius:12px;
      background:var(--primary); color:white;
      cursor:pointer; font-weight:700;
    }
    #sendBtn:disabled{ opacity:.5; cursor:not-allowed; }

    .emptyState{
      color:var(--muted);
      background:var(--card);
      border:1px dashed var(--border);
      border-radius:var(--radius);
      padding:16px;
    }
  </style>
</head>

<body>

  <div id="left">
    <div id="leftHeader">
      <div style="font-weight:900;">Chats</div>
      <div id="meLine"></div>
      <input id="search" placeholder="Search..." oninput="renderConversations()" />
    </div>
    <div id="conversations"></div>
  </div>

  <div id="right">
    <div id="chatHeader">
      <div>
        <div id="chatTitle">Select a chat</div>
        <div id="status">Realtime enabled</div>
      </div>
      <div style="font-size:12px;color:var(--muted);" id="wsState">WS: connecting...</div>
    </div>

    <div id="messagesWrap">
      <div class="emptyState">Left side ‡∂ë‡∂ö‡∑ô‡∂±‡∑ä conversation ‡∂ë‡∂ö‡∂ö‡∑ä select ‡∂ö‡∂ª‡∂±‡∑ä‡∂±.</div>
    </div>

    <div id="composer">
      <input id="text" placeholder="Type message..." oninput="onTypingInput()" />
      <button id="sendBtn" onclick="sendMsg()" disabled>Send</button>
    </div>
  </div>

<script>
let token = prompt("Paste JWT token here:");
let stompClient = null;

let myId = null;
let conversations = [];     // ConversationDto[]
let currentOtherId = null;
let currentOtherName = null;
let currentConversationId = null;

// sender typing
let typingSent = false;
let typingTimer = null;

// receiver typing (status + list)
const typingState = new Map();     // key: otherUserId -> {typing:boolean, timer:any}
let typingViewTimer = null;

function $(id){ return document.getElementById(id); }

function safeParseJwt(token){
  try{
    const base64Url = token.split('.')[1];
    const base64 = base64Url.replace(/-/g,'+').replace(/_/g,'/');
    const jsonPayload = decodeURIComponent(atob(base64).split('').map(c =>
      '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)
    ).join(''));
    return JSON.parse(jsonPayload);
  }catch(e){
    return null;
  }
}

const payload = safeParseJwt(token);
myId = payload?.userId ?? payload?.id ?? payload?.sub;
if(typeof myId === "string" && /^\d+$/.test(myId)) myId = parseInt(myId,10);

$("meLine").textContent = myId ? ("Logged as userId: " + myId) : "Token decode failed";

function fmtTime(iso){
  if(!iso) return "";
  const d = new Date(iso);
  if(isNaN(d.getTime())) return "";
  return d.toLocaleString([], {hour:'2-digit', minute:'2-digit'});
}

function initials(name){
  if(!name) return "?";
  return name.trim().split(/\s+/).slice(0,2).map(w=>w[0].toUpperCase()).join('');
}

function syncSendBtn(){
  const text = $("text").value.trim();
  $("sendBtn").disabled = !(text && currentOtherId);
}

function setHeader(name){
  $("chatTitle").textContent = name ? ("Chat with " + name) : "Select a chat";
}

function setStatus(text){
  $("status").textContent = text || "Realtime enabled";
}

function scrollToBottom(){
  const wrap = $("messagesWrap");
  wrap.scrollTop = wrap.scrollHeight + 9999;
}

// ‚úÖ helper: find conversation object by otherUserId
function getConv(otherUserId){
  return conversations.find(c => Number(c.otherUserId) === Number(otherUserId));
}

// ‚úÖ helper: update ONLY one conversation card in DOM (instant)
function updateConversationCard(otherUserId){
  const conv = getConv(otherUserId);
  if(!conv) return;

  const card = document.querySelector(`.conv[data-user-id="${otherUserId}"]`);
  if(!card) {
    // if not rendered due to search filter, re-render whole list
    renderConversations();
    return;
  }

  // time
  const timeEl = card.querySelector(".time");
  if(timeEl) timeEl.textContent = fmtTime(conv.lastMessageAt);

  // preview
  const previewEl = card.querySelector(".preview");
  if(previewEl){
    const st = typingState.get(otherUserId);
    if(st?.typing){
      previewEl.textContent = "typing‚Ä¶";
      previewEl.classList.add("typing");
    }else{
      previewEl.textContent = conv.lastMessage || "";
      previewEl.classList.remove("typing");
    }
  }

  // badge
  const rightEl = card.querySelector(".convTop > div:last-child");
  if(rightEl){
    const existingBadge = rightEl.querySelector(".badge");
    const unread = Number(conv.unreadCount || 0);

    if(unread > 0){
      if(existingBadge){
        existingBadge.textContent = unread;
      }else{
        const badge = document.createElement("span");
        badge.className = "badge";
        badge.textContent = unread;
        rightEl.appendChild(badge);
      }
    }else{
      if(existingBadge) existingBadge.remove();
    }
  }
}

// -------------------- Load Conversations --------------------
async function loadConversations(){
  const res = await fetch("/api/chat/conversations", {
    headers: { "Authorization": "Bearer " + token }
  });
  if(!res.ok){
    console.log("conversations error", res.status);
    return;
  }
  conversations = await res.json();
  renderConversations();
}

function renderConversations(){
  const q = $("search").value.trim().toLowerCase();
  const root = $("conversations");
  root.innerHTML = "";

  const filtered = conversations.filter(c => {
    const name = (c.otherUserName || "").toLowerCase();
    const msg  = (c.lastMessage || "").toLowerCase();
    const typingNow = typingState.get(c.otherUserId)?.typing === true;
    return !q || name.includes(q) || msg.includes(q) || (typingNow && "typing".includes(q));
  });

  filtered.forEach(c => {
    const div = document.createElement("div");
    div.className = "conv" + (Number(c.otherUserId) === Number(currentOtherId) ? " active" : "");
    div.dataset.userId = c.otherUserId; // ‚úÖ identify card

    const av = document.createElement("div");
    av.className = "avatar";
    if(c.otherUserPrimaryPhotoUrl){
      const img = document.createElement("img");
      img.src = c.otherUserPrimaryPhotoUrl;
      img.alt = "avatar";
      av.appendChild(img);
    }else{
      av.textContent = initials(c.otherUserName);
    }

    const main = document.createElement("div");
    main.className = "convMain";

    const top = document.createElement("div");
    top.className = "convTop";

    const name = document.createElement("div");
    name.className = "name";
    name.textContent = c.otherUserName || ("User " + c.otherUserId);

    const right = document.createElement("div");
    right.style.display = "flex";
    right.style.alignItems = "center";

    const time = document.createElement("div");
    time.className = "time";
    time.textContent = fmtTime(c.lastMessageAt);
    right.appendChild(time);

    const unread = Number(c.unreadCount || 0);
    if(unread > 0){
      const badge = document.createElement("span");
      badge.className = "badge";
      badge.textContent = unread;
      right.appendChild(badge);
    }

    top.appendChild(name);
    top.appendChild(right);

    const preview = document.createElement("div");
    preview.className = "preview";

    // ‚úÖ typing preview priority
    const st = typingState.get(c.otherUserId);
    if(st?.typing){
      preview.textContent = "typing‚Ä¶";
      preview.classList.add("typing");
    }else{
      preview.textContent = c.lastMessage || "";
    }

    main.appendChild(top);
    main.appendChild(preview);

    div.appendChild(av);
    div.appendChild(main);

    div.onclick = () => openConversation(c.otherUserId, c.otherUserName);

    root.appendChild(div);
  });
}

// -------------------- Open Chat --------------------
async function openConversation(otherId, name){
  // stop sending typing to previous chat
  sendTyping(false);

  currentOtherId = otherId;
  currentOtherName = name || ("User " + otherId);
  currentConversationId = null;

  setHeader(currentOtherName);
  setStatus("Realtime enabled");
  renderConversations();
  syncSendBtn();

  const wrap = $("messagesWrap");
  wrap.innerHTML = "";

  const res = await fetch("/api/chat/messages/with/" + otherId, {
    headers: { "Authorization": "Bearer " + token }
  });
  if(!res.ok){
    wrap.innerHTML = `<div class="emptyState">Messages load failed: ${res.status}</div>`;
    return;
  }

  const msgs = await res.json();
  if(!msgs.length){
    wrap.innerHTML = `<div class="emptyState">No messages yet. Say hi üëã</div>`;
    return;
  }

  msgs.forEach(m => {
    currentConversationId = m.conversationId ?? currentConversationId;
    addMessage(m, false);
  });

  scrollToBottom();

  // mark seen
  if(currentConversationId){
    await markSeen(currentConversationId);

    // ‚úÖ unread badge 0 instantly (without reload)
    const conv = getConv(otherId);
    if(conv){
      conv.unreadCount = 0;
      updateConversationCard(otherId);
    }
  }
}

// -------------------- Render Message --------------------
function addMessage(m, autoScroll=true){
  const wrap = $("messagesWrap");
  if(wrap.firstElementChild && wrap.firstElementChild.classList.contains("emptyState")){
    wrap.innerHTML = "";
  }

  const row = document.createElement("div");
  const isMe = (Number(m.senderId) === Number(myId));
  row.className = "bubbleRow " + (isMe ? "me" : "other");

  const bubble = document.createElement("div");
  bubble.className = "bubble " + (isMe ? "me" : "other");
  bubble.textContent = m.text ?? "";

  const meta = document.createElement("div");
  meta.className = "meta";
  meta.innerHTML =
    `<span>${fmtTime(m.createdAt)}</span>` +
    (isMe ? `<span class="seenDot">${m.seen ? "Seen" : ""}</span>` : "");

  bubble.appendChild(meta);
  row.appendChild(bubble);
  wrap.appendChild(row);

  if(autoScroll) scrollToBottom();
}

// -------------------- Seen API --------------------
async function markSeen(conversationId){
  try{
    const res = await fetch("/api/chat/messages/seen/" + conversationId, {
      method:"PUT",
      headers: { "Authorization": "Bearer " + token }
    });
    return res.ok;
  }catch(e){
    return false;
  }
}

// -------------------- Typing (Sender) --------------------
function sendTyping(isTyping){
  if(!stompClient || !currentOtherId) return;

  if(isTyping === true && typingSent === true) return;
  if(isTyping === false && typingSent === false) return;

  typingSent = isTyping;

  stompClient.send("/app/chat.typing", {}, JSON.stringify({
    toUserId: currentOtherId,
    typing: isTyping
  }));
}

function onTypingInput(){
  syncSendBtn();
  if(!currentOtherId) return;

  sendTyping(true);

  if(typingTimer) clearTimeout(typingTimer);
  typingTimer = setTimeout(() => sendTyping(false), 1200);
}

$("text").addEventListener("blur", () => sendTyping(false));

// -------------------- Send Message --------------------
function sendMsg(){
  const text = $("text").value.trim();
  if(!text || !currentOtherId || !stompClient) return;

  stompClient.send("/app/chat.send", {}, JSON.stringify({
    toUserId: currentOtherId,
    text: text
  }));

  $("text").value = "";
  syncSendBtn();
  sendTyping(false);
}

$("text").addEventListener("keydown", (e)=>{
  if(e.key === "Enter"){
    e.preventDefault();
    sendMsg();
  }
});

// -------------------- Instant update (Messages -> Left list) --------------------
function upsertConversationFromMessage(m){
  const otherId = (Number(m.senderId) === Number(myId)) ? m.receiverId : m.senderId;
  let conv = getConv(otherId);

  if(!conv){
    conv = {
      otherUserId: otherId,
      otherUserName: "User " + otherId,
      otherUserPrimaryPhotoUrl: null,
      lastMessage: "",
      lastMessageAt: null,
      unreadCount: 0
    };
    conversations.unshift(conv);
  }

  conv.lastMessage = m.text ?? "";
  conv.lastMessageAt = m.createdAt ?? new Date().toISOString();

  // if I am receiver and chat isn't open -> increment unread
  const isForMe = Number(m.receiverId) === Number(myId);
  const isOpen = Number(currentOtherId) === Number(otherId);
  if(isForMe && !isOpen){
    conv.unreadCount = Number(conv.unreadCount || 0) + 1;
  }

  // move to top
  conversations = [conv, ...conversations.filter(c => Number(c.otherUserId) !== Number(otherId))];

  // update just that card
  renderConversations();
}

// -------------------- Typing (Receiver) -> show in header + list preview --------------------
function setTypingForUser(fromUserId, isTyping){
  const id = Number(fromUserId);
  const existing = typingState.get(id) || {typing:false, timer:null};

  existing.typing = !!isTyping;

  // clear old timer
  if(existing.timer) clearTimeout(existing.timer);

  // auto-clear after 2 seconds if no new typing events
  if(existing.typing){
    existing.timer = setTimeout(() => {
      const st = typingState.get(id);
      if(st){
        st.typing = false;
        typingState.set(id, st);
        updateConversationCard(id);
        if(Number(currentOtherId) === id) setStatus("Realtime enabled");
      }
    }, 2000);
  }else{
    existing.timer = null;
  }

  typingState.set(id, existing);

  // update list preview instantly
  updateConversationCard(id);

  // header status if this is current chat
  if(Number(currentOtherId) === id){
    if(existing.typing){
      setStatus((currentOtherName || "User") + " is typing‚Ä¶");
      if(typingViewTimer) clearTimeout(typingViewTimer);
      typingViewTimer = setTimeout(()=> setStatus("Realtime enabled"), 2000);
    }else{
      setStatus("Realtime enabled");
    }
  }
}

// -------------------- Connect WS --------------------
function connectWS(){
  const socket = new SockJS("/ws");
  stompClient = Stomp.over(socket);
  stompClient.debug = null;

  $("wsState").textContent = "WS: connecting...";

  stompClient.connect(
    { Authorization: "Bearer " + token },
    function(){
      $("wsState").textContent = "WS: connected ‚úÖ";

      // messages
      stompClient.subscribe("/user/queue/messages", async function(msg){
        const m = JSON.parse(msg.body);

        // show in open chat if relevant
        const isCurrentChat =
          (currentOtherId && (Number(m.senderId) === Number(currentOtherId) || Number(m.receiverId) === Number(currentOtherId)));

        if(isCurrentChat){
          currentConversationId = m.conversationId ?? currentConversationId;
          addMessage(m, true);

          // if I am receiver and chat open -> mark seen and set unread 0
          if(Number(m.receiverId) === Number(myId) && m.conversationId){
            await markSeen(m.conversationId);
            const conv = getConv(currentOtherId);
            if(conv){
              conv.unreadCount = 0;
              updateConversationCard(currentOtherId);
            }
          }
        }

        // ‚úÖ Step D: realtime conversation list update (no loadConversations)
        upsertConversationFromMessage(m);
      });

      // typing
      stompClient.subscribe("/user/queue/typing", function(msg){
        const t = JSON.parse(msg.body); // {fromUserId, typing}
        if(!t) return;
        setTypingForUser(t.fromUserId, t.typing);
      });
    },
    function(err){
      $("wsState").textContent = "WS: error ‚ùå";
      console.log("WS error", err);
    }
  );
}

// -------------------- Init --------------------
(async function init(){
  await loadConversations();
  connectWS();
  syncSendBtn();
  setStatus("Realtime enabled");
})();
</script>

</body>
</html>
